<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>John Wong&#39;s Blog</title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 30 Jan 2015 13:52:21 +0800</pubDate>
    <lastBuildDate>Fri, 30 Jan 2015 13:52:21 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>用FauxPas找到潜在Bug</title>
        <description>&lt;p&gt;Faux Pas是一个Xcode辅助工具，检查iOS或者Mac项目，找到潜在bug，以及可维护性和风格问题。提供了92条规则可供挑选，支持GUI和CLI。目前发布了beta版，提供30天试用。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://fauxpasapp.com/&quot;&gt;Faux Pas Homepage&lt;/a&gt;
&lt;a href=&quot;http://fauxpasapp.com/try/&quot;&gt;Faux Pas Donwload&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;亲身试用后，发现了项目中的多处问题。一些需要手动查找的问题，在这里都得到了检查。同时也提供了代码风格的建议和一些细节的优化建议。&lt;/p&gt;

&lt;h2&gt;功能&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;控制潜在bug&lt;/li&gt;
&lt;li&gt;查找资源文件错误&lt;/li&gt;
&lt;li&gt;查找本地化错误&lt;/li&gt;
&lt;li&gt;发现版本控制错误&lt;/li&gt;
&lt;li&gt;学习和实施最佳实践&lt;/li&gt;
&lt;li&gt;实施代码风格&lt;/li&gt;
&lt;li&gt;代码审查清单&lt;/li&gt;
&lt;li&gt;92条规则可供挑选&lt;/li&gt;
&lt;li&gt;提供GUI或者CLI&lt;/li&gt;
&lt;li&gt;在Xcode构建时运行&lt;/li&gt;
&lt;li&gt;连接外部工具，支持导出结果和自定义脚本&lt;/li&gt;
&lt;li&gt;按标签选取规则 保存在JSON配置文件中&lt;/li&gt;
&lt;li&gt;更改打开代码的编辑器&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;使用方法&lt;/h2&gt;

&lt;h3&gt;GUI&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;打开FauxPas&lt;/li&gt;
&lt;li&gt;选择或者排除一些规则&lt;/li&gt;
&lt;li&gt;Start Checking&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;CLI&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;打开FauxPas&lt;/li&gt;
&lt;li&gt;菜单栏Faux Pas &amp;gt; Install CLI Tools…&lt;/li&gt;
&lt;li&gt;shell&amp;gt; fauxpas -t iCoupon check iCoupon.xcodeproj/&lt;/li&gt;
&lt;li&gt;可以输出不同格式、挑选检查规则等，参见帮助，例如查找重复资源&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; fauxpas --onlyRules UnusedResource -o json check MyProject.xcodeproj
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Xcode build时检查&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;确保CLI安装&lt;/li&gt;
&lt;li&gt;在Xcode项目的target中新增&amp;quot;Run Script&amp;quot; build phase&lt;/li&gt;
&lt;li&gt;添加如下脚本，build时会执行FauxPas检查&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[[ ${FAUXPAS_SKIP} == 1 ]] &amp;amp;&amp;amp; exit 0

 FAUXPAS_PATH=&amp;quot;/usr/local/bin/fauxpas&amp;quot;
 if [[ -f &amp;quot;${FAUXPAS_PATH}&amp;quot; ]]; then
   &amp;quot;${FAUXPAS_PATH}&amp;quot; check-xcode
 else
   echo &amp;quot;warning: Faux Pas was not found at &amp;#39;${FAUXPAS_PATH}&amp;#39;&amp;quot;
 fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建议不使用这种方式，会额外增加build时间。&lt;/p&gt;

&lt;h3&gt;Xcode中手动执行&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;确保CLI安装&lt;/li&gt;
&lt;li&gt;项目中创建Aggregate类型target&lt;/li&gt;
&lt;li&gt;在该target下新增&amp;quot;Run Script&amp;quot; build phase&lt;/li&gt;
&lt;li&gt;添加如下脚本，运行该target时会执行FauxPas检查&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; /usr/local/bin/fauxpas -o xcode check &amp;quot;PROJECT_NAME.xcodeproj&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;导出结果&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;GUI中点击Export Diagnostics，选择格式&lt;/li&gt;
&lt;li&gt;CLI下-o参数，可选human、json、plist、xcode&lt;/li&gt;
&lt;li&gt;导出结果可以用其他工具处理&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;实战&lt;/h2&gt;

&lt;p&gt;使用GUI扫描了项目，发现了许多不少有价值的问题，值得我们学习。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编译参数的有益建议，比如-DNDEBUG&lt;/li&gt;
&lt;li&gt;多处图片缺少和图片重复&lt;/li&gt;
&lt;li&gt;非retian与retina图尺寸不是2倍&lt;/li&gt;
&lt;li&gt;没有前缀或者前缀与SDK冲突，建议至少三字符长度&lt;/li&gt;
&lt;li&gt;Retain Delegate&lt;/li&gt;
&lt;li&gt;重载或者调用一些限制的系统方法&lt;/li&gt;
&lt;li&gt;缺少获取授权的描述&lt;/li&gt;
&lt;li&gt;Category方法冲突&lt;/li&gt;
&lt;li&gt;未使用的Error值，建议不关心Error时参数传入NULL&lt;/li&gt;
&lt;li&gt;设置delegate或者datasource为self时需要在dealloc中置为空&lt;/li&gt;
&lt;li&gt;对指针和0做比较&lt;/li&gt;
&lt;li&gt;obj ? obj : other obj将会评估2次。而obj ?: other会评估一次&lt;/li&gt;
&lt;li&gt;界面字符串缺少本地化，我们的项目实际不需要&lt;/li&gt;
&lt;li&gt;修改传入参数的值&lt;/li&gt;
&lt;li&gt;model类包含的对象的@property建议用copy，防止非setter的修改&lt;/li&gt;
&lt;li&gt;pch中引用过的头文件再次引用多余&lt;/li&gt;
&lt;li&gt;VCS建议，例如建议Xcode workspace data不忽略&lt;/li&gt;
&lt;li&gt;在init or dealloc不要使用setter。&lt;/li&gt;
&lt;li&gt;不和习惯的getter。使用something而非getSomething&lt;/li&gt;
&lt;li&gt;旧语法，例如+[NSNumber numberWithFloat:], -[NSDictionary objectForKey:]。建议转换为现代语法Edit → Refactor → Convert To Modern Objective-C Syntax&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 29 Aug 2014 00:00:00 +0800</pubDate>
        <link>/mobile/2014/08/29/using-fauxpas.html</link>
        <guid isPermaLink="true">/mobile/2014/08/29/using-fauxpas.html</guid>
        
        
        <category>mobile</category>
        
      </item>
    
      <item>
        <title>苹果的一些坑</title>
        <description>&lt;p&gt;嗯嗯，最近踩坑不少，总结一下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;OSX中文系统网络代理，如果设置了排除的网址，保存后会被系统将分隔符逗号改为顿号导致失效。所以我一直在用英文版。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;iOS地图SDK中，MKAnnotationView的centerOffset属性设置无效，是一个bug。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;iOS8槽点更多。模拟器点击关于本机之后有可能卡死。5s进入设置页点进比较深的页面，然后快速双击后退。页面内容后退两次，但是导航栏只后退了一次。AppStore闪退过。AppStore点击搜索后自动变成取消搜索的状态。wifi设置bug很多，经常变成怪异的样子。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Safari中有的图片会缺少一部分，试过Photoshop导出图片的各种选项后发现，导出时勾选连续、使用嵌入颜色配置才会显示正确。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 04 Jun 2014 00:00:00 +0800</pubDate>
        <link>/past/2014/06/04/bugs-by-apple.html</link>
        <guid isPermaLink="true">/past/2014/06/04/bugs-by-apple.html</guid>
        
        
        <category>past</category>
        
      </item>
    
      <item>
        <title>人生第一份工作</title>
        <description>&lt;p&gt;上周五入职了，开始人生的第一份工作。时隔五年后再次来到杭州，心情不一样了。本科怕工作了没时间玩，去北京晚了好多天好多地方。怕没时间去南方这么远，把江沪浙一代逛遍了。万万没想到读研去北京了，工作去杭州了。五年前总想着玩，游遍全国走向世界，现在则时刻记着肩上的担子。&lt;/p&gt;

&lt;p&gt;无聊消遣做做iOS玩，没想到成为以后的技术方向。玩跟工作毕竟不一样，要学的东西很多，我必须要加倍努力。师兄人很好，也挺关心我，团队氛围也很好。能坑自己的，恐怕只有自己。接下来就看自己能不能成为自己想成为的样子。&lt;/p&gt;
</description>
        <pubDate>Tue, 22 Apr 2014 00:00:00 +0800</pubDate>
        <link>/past/2014/04/22/first-job-in-my-life.html</link>
        <guid isPermaLink="true">/past/2014/04/22/first-job-in-my-life.html</guid>
        
        
        <category>past</category>
        
      </item>
    
      <item>
        <title>JavaEE项目切换到Intellij遇到的一个问题</title>
        <description>&lt;p&gt;换电脑真是一个麻烦的事情，尤其是像我这样需要各种环境的人。第一天折腾xcode，弄好证书什么的，把之前的一个项目跑起来。今天是折腾的第二天，只完成了一件事情，就是在mac上用Intellij Idea把之前一个项目跑起来。真心受不了MyEclipse了，慢就算了，把项目导入遇到问题，结果啥也没导入进来，根本不给修改配置解决问题的机会。&lt;/p&gt;

&lt;p&gt;问题是这样的，用Intellij新建项目，把之前的代码资源拷贝过来，运行没有问题。修改了一点代码，部署的时候代码始终没有更新。项目输出目录下，production下是更新了的，artifacts下是没更新的。重新编译、换web容器都没有用。最后发现是拷贝过来的WEB-INF目录中已经编译好的classes的问题。Eclipse是将编译好的class文件放在这个目录，Intellij编译好的并不放在这里，不知道哪一步就导致这里的classes文件复制到输出目录，并导致新编译的class文件被覆盖。&lt;/p&gt;

&lt;p&gt;解决方法就是把web目录下的classes目录删除掉。&lt;/p&gt;
</description>
        <pubDate>Tue, 25 Feb 2014 00:00:00 +0800</pubDate>
        <link>/past/2014/02/25/javaee-to-intellij.html</link>
        <guid isPermaLink="true">/past/2014/02/25/javaee-to-intellij.html</guid>
        
        
        <category>past</category>
        
      </item>
    
      <item>
        <title>Geoguessr游戏破解</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://geoguessr.com/&quot;&gt;Geoguessr&lt;/a&gt;是一个好玩的根据街景猜位置的游戏。建议先玩玩，充分体会游戏的乐趣。学会了破解的方法就没意思了。接下来进入破解方法。需要Chrome浏览器和Web调试的一点知识。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2014-02-11-hack-geoguessr.png&quot; alt=&quot;geoguessr&quot;&gt;&lt;/p&gt;

&lt;h4&gt;1. 捕捉街景的网络交互。&lt;/h4&gt;

&lt;p&gt;按F12打开调试工具。刷新网站，加载完成后在network选项卡下凭借缩略图能够很快找到街景的网络请求。我这里找到的是&lt;code&gt;https://cbks0.googleapis.com/cbk?output=tile&amp;amp;cb_client=apiv3&amp;amp;v=4&amp;amp;zoom=4&amp;amp;x=4&amp;amp;y=3&amp;amp;panoid=GUkoc-YOhxYusUlRmRiuvw&amp;amp;fover=2&amp;amp;onerr=3&lt;/code&gt;。其中的参数panoid让我想起了单词panorama，这个就是街景的id。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2014-02-11-hack-geoguessr2.png&quot; alt=&quot;geoguessr&quot;&gt;&lt;/p&gt;

&lt;h4&gt;2. 街景id转成经纬度。&lt;/h4&gt;

&lt;p&gt;Google街景的地址的格式是&lt;code&gt;http://maps.google.com/?hl=en&amp;amp;ie=UTF8&amp;amp;ll=42.843751,-68.203125&amp;amp;spn=0,313.461914&amp;amp;z=5&amp;amp;layer=c&amp;amp;cbll=41.916553,-75.883875&amp;amp;panoid=zRjnm1iOEUZN_ueQbq6MlQ&amp;amp;cbp=12,278.28,,0,6.02&lt;/code&gt;，把这里的panoid换成刚才得到的街景id。我使用的是新版Google Maps，地址格式是&lt;code&gt;https://www.google.com/maps/preview/@47.528448,-92.168024,3a,75y,294.09h,71.36t/data=!3m4!1e1!3m2!1sGUkoc-YOhxYusUlRmRiuvw!2e0?hl=en&lt;/code&gt;，街景id是!1s与!2e之间的部分。打开替换街景id后的链接，就能在地址中找到经纬度47.528448,-92.168024。&lt;/p&gt;

&lt;h4&gt;3. 控制地图中心。&lt;/h4&gt;

&lt;p&gt;这是可以收到能够拖动地图中心到找到的经纬度。也可以用代码注入的方法控制地图拖动缩放。Google Maps API新建地图的语句是new google.maps.Map。搜索代码功能以前是在调试工具的Resources选项卡下，现在变成了按Esc调出drawer，选中search选项卡搜索。搜到了三处，都在geoguessr.js中。从名字来看，guessMapView这个变量最可能是猜结果的地图。在控制台的变量中找不到这个实例，应该是包在函数中了，就通过断点注入来插入代码。在sources选项卡中找到这个变量定义的地方，可以点击尖括号图标来让Chrome帮你完成代码格式化方便阅读。找一个能访问资源的功能，例如showHelp定义的地方打断点。点击界面的帮助按钮，就会停在断点处。之前记得先在猜的地图上把红色的标记点出来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2014-02-11-hack-geoguessr3.png&quot; alt=&quot;geoguessr&quot;&gt;&lt;/p&gt;

&lt;p&gt;控制台输入代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;google&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;maps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;LatLng&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;47.528448&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;92.168024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;guessMapView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setCenter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;guessMapView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;guessMarker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setPosition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;继续执行脚本。回到页面点Make Guess就通关了，得到用于炫耀的链接哈哈。&lt;code&gt;http://url.geoguessr.com/6nYg&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;不得不说猜到中国的时候坑比较大啊，因为众所周知的国内地图被要求加一个偏差。其中有一关街景是在湖边的路上，答案要点在湖里面。&lt;/p&gt;
</description>
        <pubDate>Tue, 11 Feb 2014 00:00:00 +0800</pubDate>
        <link>/past/2014/02/11/hack-geoguessr.html</link>
        <guid isPermaLink="true">/past/2014/02/11/hack-geoguessr.html</guid>
        
        
        <category>past</category>
        
      </item>
    
      <item>
        <title>Sencha Touch跨域问题解决</title>
        <description>&lt;p&gt;之前对于跨域问题仅有粗浅的认识，一般是浏览器层面出于安全性的考虑，不允许调用其他页面的对象。这次在Sencha Touch中解决这个问题额外花掉不少时间。&lt;/p&gt;

&lt;p&gt;解决的方法大概就是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;修改服务器的header；&lt;/li&gt;
&lt;li&gt;JsonP。JsonP方法是一种非官方的解决方案，只支持Get方法，需要服务器端根据callback参数返回不同的内容。返回的内容不是标准的json&amp;#26684;式，对服务器端的改动会比较麻烦。我选择了修改服务器返回的header的方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;1. 修改header的Access-Control-Allow-Origin&lt;/h4&gt;

&lt;p&gt;将header的Access-Control-Allow-Origin设为允许的域名列表，我这里直接设置为星号了。项目采用的是SSH的架构。在jsp文件中，可以使用response.addHeader方法修改header，在所有页面都会包含的公共文件中加入即可。更好的办法是写一个Filter，对json请求的路径拦截，修改header：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;httpResponse&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HttpServletResponse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;httpResponse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addHeader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Access-Control-Allow-Origin&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;*&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于iframe跨域的问题，可以将设置“P3P&amp;quot;为&amp;quot;CP=CAO PSA OUR&amp;quot;。&lt;/p&gt;

&lt;h4&gt;2. 修改header的Access-Control-Allow-Headers&lt;/h4&gt;

&lt;p&gt;在新版的Chrome浏览器下，上述方法仍然无法达到目的，需要将header的Access-Control-Allow-Headers设为Origin, X-Requested-With, Content-Type, Accept。&lt;/p&gt;

&lt;h4&gt;3. 修改Sencha Touch&lt;/h4&gt;

&lt;p&gt;一般情况下跨域问题已经解决了。在Sencha Touch下发现每一个Ajax请求都发送了两次，其中一次的请求方法为OPTIONS。我只知道常用的Get、Post，听说过Put、Delete。查过后才知道OPTIONS方法是用于获取指定URL能接收的请求方法。我用jQuery发送GET请求没有出现，手写HttpXmlRequest也没有出现。这样的问题在StackOverFlow和Sencha论坛上也看到有不少人遇到。用Web调试工具找发送OPTIONS请求的地方，没有找到。对于jQuery和Sencha的http请求头，发现了问题所在。Sencha发送的头中包含了X-Requested-With的头，jQuery中没有。估计是这个请求头触发了浏览器去探测该URL可用的请求方法。大多服务器都不支持这个方法，觉得Sencha这么做是多此一举了。如果是使用Ext.Ajax.request发送请求，直接在配置中写useDefaultXhrHeader
 : false就可以了。但是这里是将请求用在Ext.data.Store中，不支持这个配置。懒得该太多源文件支持这个配置，直接将Connection.js中这个配置的默认&amp;#20540;改为false。&lt;/p&gt;

&lt;p&gt;另外还遇到Sencha Touch编译的坑。特定版本编译报Logger.js不存在，需要将app.json中的buildOptions下logger的&amp;#20540;由&amp;quot;no&amp;quot;改为&amp;quot;false&amp;quot;。接下来需要解决的sencha touch的坑是开发环境运行问没问题，编译后界面部分不显示，交互出问题。&lt;/p&gt;

&lt;p&gt;感谢IBM实习的机会，让我学会了Web调试。感谢万能的StackOverFlow，能找到各种问题的解决方案。&lt;/p&gt;
</description>
        <pubDate>Fri, 07 Feb 2014 00:00:00 +0800</pubDate>
        <link>/past/2014/02/07/cross-origin-in-sencha-touch.html</link>
        <guid isPermaLink="true">/past/2014/02/07/cross-origin-in-sencha-touch.html</guid>
        
        
        <category>past</category>
        
      </item>
    
      <item>
        <title>Android Studio踩坑记</title>
        <description>&lt;p&gt;拾起Android项目，需要使用Goolgle Play Services。顺应潮流换了Android Studio，开启了踩坑之旅。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;尝试直接将Eclipse项目导入AS，结果根本没法用啊。正确的方法应该是升级ADT，在Eclipse下导出build.gradle然后再导入。但是升级的时间还不如直接新建项目把资源拷进去，同时也能了解一下AS默认的项目结构。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第一个遇到的问题是新建的项目没有assert和lib目录。java和res等资源都在src/main目录下，于是我将assets和libs目录都放在这了。结果assets目录没问题，但是实际上要在gradle文件中引用libs目录，libs目录应该放在src下。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;加入jar包没有那么简单，放入libs目录下之后还需要：右击lib选择添加为lib；在项目中添加库引用；在build.gradle中添加对这个jar的依赖；手动在项目目录下运行gradew clean。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;想要使用gms，最新的方法是在SDK manager中安装Google Play Services和Google Repository，在dependencies中添加：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    compile &amp;#39;com.android.support:support-v4:19.0.0&amp;#39;
    compile &amp;#39;com.android.support:appcompat-v7:19.0.0&amp;#39;
    compile &amp;#39;com.google.android.gms:play-services:4.1.32&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这里的版本号也是略坑爹，想知道版本号需要打开目录&lt;SDK&gt;\extras\google\m2repository\com\google\android\gms\play-services，然后就能看到可用的版本号，其他两个包也是类似的方法查看。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载的play services目录重要示例工程，本还想参考一下，结果都没有升级成新的工程结构。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Play Services安装文档中指明需要添加：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;meta-data android:name=&amp;quot;com.google.android.gms.version&amp;quot;
           android:value=&amp;quot;@integer/google_play_services_version&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是这个版本号略坑。平时看到的都是x.x.xx这样的格式，而不是整数。最终在sdk\extras\google\google&lt;em&gt;play&lt;/em&gt;services\libproject\google-play-services_lib\AndroidManifest.xml中找到了版本号4132530，运行之后提示需要的是4132500，为什么要减去30至今没搞明白。需要放在application节点下，我还错误地放在manifest节点下。&lt;/p&gt;

&lt;p&gt;最后吐槽一下打开的各种弹窗太大了，我这1366×768分辨率的笔记本经常看不到下边的内容。第一次运行AS的时候还有长时间走滚动条的问题，据说是在下载gradle，不过我没有感觉到。因为用电脑是需要和小外甥打游击，不能被看到，下载的时候把电脑藏起来干别的去了。&lt;/p&gt;

&lt;p&gt;jni库始终无法正常加入安装包中。没事升级AS到0.4.3，之前jar包引用又出问题了，就在决定今天无法解决就换回Eclipse之际，一篇帖子帮了大忙：http://blog.csdn.net/look_down/article/details/17557031&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;build.gradle中gradle版本修改为0.7+&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行后出错，按照提示修改gradle-wrapper.properties文件中&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;加入so库的代码修改为：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;task copyNativeLibs(type: Copy) {  
    from fileTree(dir: &amp;#39;libs&amp;#39;, include: &amp;#39;armeabi/*.so&amp;#39; )  into  &amp;#39;build/lib&amp;#39;  
}  
tasks.withType(Compile) {  
    compileTask -&amp;gt; compileTask.dependsOn copyNativeLibs  
}  

clean.dependsOn &amp;#39;cleanCopyNativeLibs&amp;#39;  

tasks.withType(com.android.build.gradle.tasks.PackageApplication) { pkgTask -&amp;gt;  
   pkgTask.jniFolders = [new File(buildDir, &amp;#39;lib&amp;#39;)]  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过gradlew clean build之后成功了。这下没有理由再用Eclipse了。&lt;/p&gt;
</description>
        <pubDate>Fri, 31 Jan 2014 00:00:00 +0800</pubDate>
        <link>/past/2014/01/31/trap-in-android-studio.html</link>
        <guid isPermaLink="true">/past/2014/01/31/trap-in-android-studio.html</guid>
        
        
        <category>past</category>
        
      </item>
    
      <item>
        <title>最近部署一个小项目的一些坑</title>
        <description>&lt;p&gt;一个小项目，最近要部署，一个劲踩坑。每踩一次就得往甲方公司多跑一趟。苦于自己电脑不能接入公司网络，不能装各种工具，手动做费死劲。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;为了传文件，需要电脑开Filezilla，开wifi，开Connectify，然后用公司电脑连接到我电脑的ftp。使用mac系统的时候还得先重启进windows。累屎人了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;导数据，需要先导出sql文件，用上面的方法传到公司电脑，再传到服务器。还要处理Mysql与Oracle的sql&amp;#26684;式问题，深刻怀念Navicat。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;之前调试使用一个库，现在改成读写一个库，只读另一个库。Spring 2.5默认支持一个数据源。默默地升级到Spring3，暂时先将只读库需要的数据同步过来，以后再慢慢做双数据源。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;开发的时候部署过一次，用的是Tomcat。但是生产环境要用Weblogic，Hibernate与JPA的持久化层出问题，还没解决完。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;iOS模拟器用得飞起，需要装到设备上的时候，证书问题都忘光了。甲方的证书不到位，之前账号加入别的公司的组中，已经过期被踢了。幸好还有一个账号能用。于是倒腾证书、添加设备、Provision Profile。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;iOS SDK的问题真是麻烦。我电脑上两个xcode分别支持6.0和5.1，各种设备都是iPhone4，版本6.1.3和5.0。于是都不能调试。回去之后升级了xcode到支持6.1，第二天来公司设备调试还是有问题，最后stackoverflow拯救了我，去掉架构里的armv7s就没问题了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PS. 农行良心企业啊，给Offer啦。可是有效期内学校不可能给新三方，愁死我了。&lt;/p&gt;
</description>
        <pubDate>Fri, 10 Jan 2014 00:00:00 +0800</pubDate>
        <link>/past/2014/01/10/hard-to-deploy.html</link>
        <guid isPermaLink="true">/past/2014/01/10/hard-to-deploy.html</guid>
        
        
        <category>past</category>
        
      </item>
    
      <item>
        <title>Scala程序设计读书笔记[11:14]</title>
        <description>&lt;h3&gt;第十一章 与Java互操作&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在Scala里使用Scala类  如果在脚本中使用，不需编译被引用的Scala类。如果在编译过的Scala或Java代码中使用就需要编译。指定代码目录为entities和当前目录：&lt;code&gt;scala -sourcepath entities:. userPerson.scala&lt;/code&gt;。编译引用类： &lt;code&gt;scalac -d . -classpath LocationOfPersonClassFile usePersonClass.scala&lt;/code&gt;。用java运行时只要指定scala-library.jar即可：&lt;code&gt;java -classpath path/scala-library.jar:. UsePersonClass&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在Scala里使用Java类  如果Java类是标准JDK的一部分，直接用。如果不在java.lang里，就要导入类的包。如果Java类是自己创建的或者第三方，需要用classpath指向字节码位置。如果Java代码有方法或者字段的名字和Scala的关键字冲突，在scala中将冲突的变量/方法放到反引号里。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在Java里使用Scala类  运行时需要将scala-library.jar加入classpath。Scala默认不遵守JavaBean约定，要用@scala.reflect.BeanProperty这个注解生成符合JavaBean约定的getter和setter。如果Scala类有方法由接收闭包，在Java里就不可用。Scala不支持interface关键字，如果想创建接口就创建一个没有实现的trait。Scala将对象（单例对象或伴生对象）编译成一个单例类，类末尾名字有一个$符。单例类会同时创建一个普通类，把调用传给单例类，类名直接访问，例如Buddy.greet()。如果对象是同名类的伴生对象，Scala会创建两个类，一个表示Scala类，另一个表示伴生对象，末尾加$。访问伴生对象需要使用符号MODULE$，如Buddy$.MODULE$.greet()。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;继承类  Scala类和Java类可以互相继承。如果方法接受闭包为参数，重写起来有些麻烦。异常也是个问题。Scala没有throws语句，任何方法可以抛出异常，无需显式声明成方法签名的一部分。如果在Java中重写这样的类，在Scala中方法定义前加注解@throws(classOf[NoFlyException]) def fly();。Scala支持注解但是不提供创建注解的语法。如果想创建注解就不得不用Java类做。@throws是已经提供好的注解。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;第十二章 用Scala做单元测试&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用JUnit  用Scala写好测试后编译成字节码，然后运行测试。编译运行时将JUnit的jar加入classpath。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用ScalaTest  有着精炼的语法和函数式风格，既可以测试Scala代码，也可以测试Java代码。地址&lt;a href=&quot;http://www.artima.com/scalatest&quot;&gt;http://www.artima.com/scalatest&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;以Canary测试开始  创建类继承org.scalatest.Suite，之后创建该类实例并执行execute方法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用Runner  用来测试多个套件。&lt;code&gt;scala -classpath $SCALATEST:. org.scalatest.tools.Runner -p .&lt;/code&gt;，p指定查找套件的路径。-o可以重定向输出到标准输出而不是GUI，-f重定向到文件。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Asserts  ScalaTest提供了===操作符，与assert()方法相比可以打印出更多信息。可以传入第二个参数，传入更多消息。如果检查两个值相等，使用expect，接收一个期望值，一个可选的消息，一个闭包。比较闭包里表达式执行结果与期望值是否相等。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;异常测试  异常测试确保被测试的代码单元可以抛出预期的异常。使用try-catch-finally，但是catch中使用的是模式匹配语法。try最后放入fail方法，这样不抛出异常或者抛出未被捕获的异常都会失败。简洁一些可以写成intercept(classOf[IndexOutOfBoundsException], &amp;quot;&amp;quot;){list.get(0)}。接收一个异常类作为参数，一个可选的错误消息，一个闭包。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在测试间共享代码  用BeforeAndAfter trait共享代码。提供了beforeEach和afterEach方法，类似setUp和tearDown方法。还提供了beforeAll和afterAll方法。用闭包共享代码。应用6.7节Execute Around Methond模式，定义一个withList方法，传入函数。方法体内定义List，在try-finally块中传给函数执行，在finally中做一些执行后的任务。可以在多个测试的方法中调用withList，传入要做的测试。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;FunSuite的函数式风格  继承FunSuite，不再写测试方法，而是调用一个名叫test()的方法，给它提供一个有意义的测试名字和一个闭包，闭包中是测试的主体。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用JUnit运行ScalaTest  让测试套件继承JUnit3Suite，在main方法中junit.textui.TestRunner.run(classOf[UsingJUnit3Suite])。这样能用Scala和JUnit来运行ScalaTest写的测试，不存在JUnit(或TestNG)与ScalaTest之间二选一的问题。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;第十三章 异常处理&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;异常处理  可以像Java一样抛出异常throw new WhatEverException，使用try-catch-finally。catch语句中使用case模式匹配来处理异常。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注意catch顺序  如果放了多个catch块，Java会监控他们的顺序。Java中后面Exception执行不到会得到编译错误，scala中不会给出警告，因此使用多个catch块时，必须确保异常由预期的catch块处理。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;第十四章 使用Scala&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;获取用户输入  Console.readLine&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;读写文件  写文件：val writer = new PrintWriter(new File(&amp;quot;a.txt&amp;quot;))   writer write &amp;quot;abc&amp;quot;   writer.close()。读文件：import scala.io.Source  Source.fromFile(&amp;quot;a.txt&amp;quot;).foreach{print}。如果需要一次读一行，就用getLines方法。fromURL方法接收java.net.URL对象，从网络读取数据。getLine方法返回指定行，以1为起始索引。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;XML作为一等公民  Scala中可以将xml文档之间放入代码就像int或Double一样。 val xml = &lt;symbols&gt;&lt;symbol&gt;a&lt;/symbol&gt;&lt;/symbols&gt;。类似XPath的查询提取方法xml \ &amp;quot;symbol&amp;quot;，查找其直接后代，传入的字符串@起始，则查找属性。如果要从目标元素出发，搜出层次结构里所有元素，就要用\方法。text方法获取元素里的文本节点。可以使用模式匹配来提取xml中的信息&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;读写XML  &lt;code&gt;import scala.xml.*  XML.load(&amp;quot;stocks.xml&amp;quot;)。XML.save(&amp;quot;stocks2.xml&amp;quot;, xml)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GUI  scala.swing.SimjpleGUIApplication，实现top方法，返回一个Frame。目前deprecated Since version 2.8.0 Use SimpleSwingApplication instead。可以使用JavaFX2 (and ScalaFX, which provides a nice Scala API for JavaFX2)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Finished! 不过看完书离熟悉还有很大差距&lt;/p&gt;
</description>
        <pubDate>Sat, 26 Oct 2013 00:00:00 +0800</pubDate>
        <link>/past/2013/10/26/programming-scala-11-14.html</link>
        <guid isPermaLink="true">/past/2013/10/26/programming-scala-11-14.html</guid>
        
        
        <category>past</category>
        
      </item>
    
      <item>
        <title>Scala程序设计读书笔记[6:10]</title>
        <description>&lt;h3&gt;第六章 函数值和闭包&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;高阶函数  以其它函数为参数的函数。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数值  可以在函数里创建函数，将函数赋给引用。函数参数中例如codeBlock: Int =&amp;gt; Int。函数值包含多行代码或者作为参数传入时有多个参数，需要用圆括号包起来。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;具有多参数值的函数值 具有多个参数的函数值例如operation: (Int, Int) =&amp;gt; Int)。想要遍历容器中元素，执行一些操作可以使用foldLeft方法，即/:。使用方法，0为初值：array.foldLeft(0){}，(0 /: array){}。尖括号中为两参数函数值如(a, b) =&amp;gt; a+b。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Curry化 curry化可以把函数从接收多个参数变成接收多个参数列表。用一组实参多次调用同一个函数的时候能够用curry化来减少噪音？定义时每组参数用括号包起来。调用时可以用个括号或者尖括号。但是第一个参数列表必须使用括号。非第一个参数列表只能一个参数。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重用函数值 将函数值赋给var或者val可以。重用函数值而不是参数列表。似乎必须指明返回类型例如：{ input : Int =&amp;gt; input }&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;参数位置记法  如果某个参数在函数里只使用一次，就可以下划线可以表示。(a, b) =&amp;gt; Math.max(a, b)可以协作Math.max(_, _)。也可以表示整个参数列表，协作Math.max _。如果只是传给下层甚至协作Math.max。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Execute Around Method  假设有个类需要自动开启事务，在用完对象之后需要显示的结束事务。正确启动事务可以依赖于构造函数，终结部分有些棘手，可以用Execute Around Method。利用私有类和伴生类。伴生类的一个方法接收函数值作为参数，创建私有类的实例，在try和finally块的保护下把实例传给传入的函数值。调用的时候传入代码块，就能按照代码块执行资源的操作，并确保调用finally中的清除方法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Loan Pattern  上个模式的变体。在方法有函数值参数，方法内创建资源，并在try和finally的保护下将资源传给函数值，finally中做资源释放。调用时传入代码块。代码块中可以得到资源的实例。代码块执行完毕后会释放资源。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;偏应用函数  偏应用函数相对全应用函数，只接收部分参数，将未接收的参数绑定到全应用函数上。val logWithDateBound = log(new Date, _ : String)。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;闭包  闭包是可以包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义。在Scala中传入的代码块中可以使用定义代码块环境中的变量。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;第七章 Trait和类型转换&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Trait  指的是可以混入或者融入一个类层次结构的行为。就像一个拥有部分实现的接口，提供了一个介于单一继承和多重继承的中间地带。trait里定义和初始化的val和var会混入trait的类内部得以实现。定义过而未被初始化的val和var则认为是抽象的，需要由混入这些trait的类实现。如果类不继承其他类，可以用extends关键字混入trait。用关键字with可以混入更多的trait。一个类混入trait后，通过它的实例可以调用trait的方法，也可以把它当作trait的引用。与类的区别：a)需要混入类去实现已声明而未初始化的变量和值；b)其构造器不能有任何参数。trait会编译为Java的接口，还有对应的实现类，里面包含了trait实现的方法。k&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;选择性混入  还可以再实例一级对trait进行选择性混入，就可以把特定的类的实例当作trait，使用with。new Cat with Friend。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;trait用于装饰模式  trait可用于装饰对象，使其具有一些能力。class Check有check方法。定义trait CreditCheck和EmploymentCheck继承Check，复写其check方法，最后调用super.check。这样new Check with CreditCheck with EmploymentCheck check将会依次调用EmploymentCheck、CreditCheck和Check的check方法，给Check的check方法增添了额外的功能。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Trait方法的延迟绑定  如果Check的check方法未实现，则Check必须为abstract，同时继承Check的trait也必须将check标为abstract，无论其有没有实现。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;隐式类型转换  将方法标记为implicit，只要它在当前范围存在（通过import可见或者位于当前文件），scala就会自动调用。方法名格式为convertInt2DateHelper。scala一次至多应用一个隐式转换。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;第八章 使用容器&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;常见Scala容器  List/Set/Map。scala虽然提供了可变容器和不可变容器，但是如果想修改容器而且对容器的所有操作都在一个线程里，可以选择可变容器。如果计划跨线程或者跨actor使用容器，不变容器更好。不仅线程安全，而且没有副作用。可选包为scala.collection.mutable或scala.collection.immutable。不必用新建，可以用Set(1, 2)来创建，scala会调用apply方法，也成工厂方法。容器类型不必指定，得到的是Set[Int]。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用Set  调用filter方法找到包含指定字符的set子集：feeds filter ( _ contains &amp;quot;blogspot&amp;quot;)。set使用指定间隔符转string：mkString(&amp;quot;, &amp;quot;)。+方法添加元素，返回的是新容器。++可以合并两个set。**求交集。map方法对每个元素应用传入的函数值，返回结果的数组。toArray转为数组。数组可以apply方法（apply可以省略）取得元素。书中set.toArray(0)的写法编译错误，需要一个引用p指向数组，之后p(0)返回第一个元素。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用Map  Map(1-&amp;gt;2, 2-&amp;gt;3)。filterKeys根据键过滤，filter根据键值对过滤。get根据值返回键，返回的是Option。apply方法返回值，不存在则抛出异常。update方法现在变为updated，修改键对应的值，不存在则添加键值，返回新map。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用List  List只有不变的实现。head访问第一个元素，tail访问最后一个元素。可以用apply方法访问指定索引的值。在前面添加元素可以用1::a，合并List a:::b。filter可以筛选，forall可以检查是否都符合条件，exists判断是否有满足条件的元素。还有方法map、foldLeft、foldRight。foldRight类似，但是从又开始计算。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方法命名约定  :提升流畅性，:在后表示调用目标是运算符后面的实例，例如::。同样调用目标是后面的还有一元运算符+、-、!、~。+映射为unary_+，其他三个也一样。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;for表达式  foreach提供了内部迭代器，不必控制循环。控制循环需要用for。for表达式接收的参数包括一个或多个生成器，0或多个定义，还有0或多个过滤器，分号分隔。yield关键字可选，表示返回一个多值容器，而不是一个Unit。也可以用map实现循环控制(1 to 10).map()。添加过滤器：for(i &amp;lt;- 1 to 10; if i % 2 == 0) yield i * 2。也可以将分号替换为换行符，括号改写为尖括号。生成器里可以定义变量，每个迭代里都会以这个名字定义一个新的val。如果for表达式里提供了多个生成器，则每个生成器都会形成一个内部循环。最右的生成器控制这最内的循环。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;第九章 模式匹配和正则表达式&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;匹配字面量和常量  match是一个对Any起作用的表达式。它会对目标执行模式匹配，传入的代码块使用case表达式。匹配通配符  case后使用_可以代替default。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;也可以匹配元组和列表  数组对于不关心的元素，可以用&lt;em&gt;省略，多个可以用&lt;/em&gt;*。如果需要引用余下的项可以用在通配符前加变量名和@。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类型和卫戍句的匹配  case msg: Int =&amp;gt; ...也可以case msg: Int if (msg &amp;gt; 100) 这样匹配类型和值。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;case表达式里的模式变量和常量  模式变量以小写字母开头，常量以大写字母开头。如果在当前作用域内有一个有着与模式变量同样名字的字段将会报错。这时占位符需要显示指定作用域，如this.xx或者伴生对象Object.xx。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用case类进行模式匹配  case类对case进行了一定程度的封装。定义abstract case class，并定义一些cass class继承刚才的类。首先匹配case class是否相同，然后再匹配case class的参数是否符合。如果定义为sealed abstract cass class，就告诉scala除了这个文件中的case class的子类，不会有其他子类，这样如果定义了case class的子类但是匹配的时候没有出现，就会报编译错误。如果定义的case class没有参数，记得用的时候记得加括号。不然传入的是伴生对象。这个伴生对象混入了scala.Function0 trait，以为这传入的是一个函数，而不是对象。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用提取器进行匹配  定义包含unapply方法的object，返回Boolean或者Option。如果返回false或者None则不匹配。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;正则表达式   RichString的r方法返回Regex实例。可以使用&amp;quot;&amp;quot;&amp;quot;来避免使用转义。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;正则表达式当作提取器  val MatchStock = &amp;quot;&amp;quot;&amp;quot;^(.+):(\d*.\d+)&amp;quot;&amp;quot;&amp;quot;.r  ...   case MatchStock(&amp;quot;GooG&amp;quot;, price) =&amp;gt; println(...)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;第十章 并发编程&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;促进不变性  使用可变对象写出线程安全代码极端困难，不变对象从根源上解决了这个问题。Scala的并发模型依赖不变性，希望我们把不变对象当作消息在actor间传递。不变性优势有：
a) 天生线程安全，无法修改状态
b) 没有复杂的状态转换，简单易用
c) 可以在应用间共享和重用。
d) 不易出错，因为不会随意改变对象状态。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用Actor并发  actor提供了一种基于事件的轻量级线程。使用scala.actors.Actor伴生对象的actor()方法，就可以创建一个actor。它接受一个函数值/闭包做参数，一创建好就开始运行。用!()方法给actor发消息，receive方法从actor接收消息，通过case取回消息。receive也可以闭包为参数，通常用模式匹配处理接收到的消息。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息传递  发送不阻塞，接收不中断。在actor调用receive方法接收之前，消息一直等在那里。mailboxSize是receive方法中的隐含参数，消息的数量。同步发送和接收消息使用!?()方法。不过可能引起潜在死锁。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Actor类  之前使用Actor单例对象的actor方法，大多数情况下够用。如果想在actor启动时进行显式控制，希望在actor里存入更信息，可以创建一个对象，混入Actor trait。调用start()方法会有单独线程处理actor的act方法。exit()方法可以中止线程执行。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;actor方法  用actor()方法创建一个匿名的actor。actor会在另外线程中执行。与actor交互的顺序是没有保证的。actor对消息的接收和处理没有预先强加的顺序。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;receive和receiveWithin方法  receive接收一个函数值/闭包，返回一个处理消息的应答，会造成阻塞。receiveWithin接收一个timeout参数，其中case可以为TIMEOUT，用于超时时的处理。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;react和reactWithin方法  receive和receiveWithin方法的actor具有线程关联性；他们会持续使用分配给他们的同一个线程。react和reactWithin的actor不具有线程关联性，可以自由的交换彼此的线程，可以由任何可用的线程处理。鼓励使用react代替receive。副作用是在处理消息的末尾调用适当方法，否则actor不再处理任何消息。loop和loopWhile是更好的处理方法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;loop和loopWhile&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;控制线程执行  shiyong receive时每个actor运行在自己的线程里，react让actor共享来自线程池的线程。SingleThreadedSchedule可以让Scala在主线程里运行actor。Scheduler.impl = new SingleThreadedScheduler 可以使主线程里运行actor。想要使某个actor在一个线程中运行，需要类继承Actor，覆写scheduler方法，返回SingleThreadedScheduler的实例。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在各种接收方法中选择  应该使用within的方法，以便在一段时间没有收到响应式恢复过来。如果想要在一个工作流执行中间从另一个actor接受消息，那么receiveWithin很合适，actor会一直阻塞知道收到消息，不过actor不能太多，因为每一个在结束之前都会持有一个线程。另一方面如果想要实现一个服务接收消息，快速响应调用者，应该使用reactWithin，在等待消息到来期间不会持有线程。如果不确定用哪一个，在reactWithin不能满足需求时再使用receiveWithin。记住要在loopWhile里调用reactWithin，以便actor可以持续处理更多消息。如果更倾向于函数式风格，也可以在reactWithin里递归调用方法。如果reactWithin里只有一两个case语句，后一种方法也可以。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 26 Oct 2013 00:00:00 +0800</pubDate>
        <link>/past/2013/10/26/programming-scala-06-10.html</link>
        <guid isPermaLink="true">/past/2013/10/26/programming-scala-06-10.html</guid>
        
        
        <category>past</category>
        
      </item>
    
  </channel>
</rss>
